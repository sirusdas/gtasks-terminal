
#!/usr/bin/env python3
"""
Advanced Sync Manager - Enhanced synchronization between local tasks and Google Tasks
with support for push/pull operations and conflict resolution.
"""

import os
import sqlite3
import tempfile
import traceback
from typing import List, Dict, Optional, Set, Tuple
from datetime import datetime, timedelta
import hashlib
import json

from gtasks_cli.utils.logger import setup_logger
from gtasks_cli.models.task import Task, TaskStatus
from gtasks_cli.storage.local_storage import LocalStorage
from gtasks_cli.integrations.google_tasks_client import GoogleTasksClient
from gtasks_cli.utils.task_deduplication import create_task_signature, get_existing_task_signatures
from gtasks_cli.utils.datetime_utils import _normalize_datetime
from gtasks_cli.storage.config_manager import ConfigManager

logger = setup_logger(__name__)


class AdvancedSyncManager:
    """Advanced synchronization manager for Google Tasks with SQLite storage backend."""
    
    def __init__(self, storage, google_client):
        """
        Initialize the AdvancedSyncManager.
        
        Args:
            storage: An instance of a storage backend (e.g., LocalStorage, SQLiteStorage)
            google_client: An instance of GoogleTasksClient
        """
        self.local_storage = storage
        self.google_client = google_client
        self.sync_metadata_file = os.path.join(
            os.path.expanduser("~"), ".gtasks", "advanced_sync_metadata.json"
        )
        self.deletion_log_file = os.path.join(
            os.path.expanduser("~"), ".gtasks", "deletion_log.json"
        )
        self.sync_metadata = self._load_sync_metadata()
        self.config_manager = ConfigManager()
    
    def _load_sync_metadata(self) -> Dict:
        """
        Load synchronization metadata.
        
        Returns:
            Dict: Sync metadata
        """
        if os.path.exists(self.sync_metadata_file):
            try:
                with open(self.sync_metadata_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.warning(f"Failed to load sync metadata: {e}")
        
        # Return default metadata structure
        return {
            "last_sync": None,
            "last_push": None,
            "last_pull": None,
            "local_task_versions": {},
            "google_task_versions": {},
            "task_mappings": {},  # Maps local task IDs to Google task IDs
            "conflicts": [],
            "sync_log": []  # Log of sync operations
        }
    
    def _save_sync_metadata(self):
        """Save synchronization metadata."""
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.sync_metadata_file), exist_ok=True)
            
            with open(self.sync_metadata_file, 'w') as f:
                json.dump(self.sync_metadata, f, indent=2, default=str)
            logger.debug("Sync metadata saved successfully")
        except Exception as e:
            logger.error(f"Failed to save sync metadata: {e}")
    
    def _log_deletion(self, task: Task, reason: str):
        """
        Log task deletion to a deletion log file.
        
        Args:
            task: The task that was deleted
            reason: Reason for deletion
        """
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.deletion_log_file), exist_ok=True)
            
            # Load existing deletion log
            deletion_log = []
            if os.path.exists(self.deletion_log_file):
                with open(self.deletion_log_file, 'r') as f:
                    try:
                        deletion_log = json.load(f)
                    except json.JSONDecodeError:
                        deletion_log = []
            
            # Add new deletion entry
            deletion_entry = {
                "timestamp": datetime.utcnow().isoformat(),
                "task_id": task.id,
                "task_title": task.title,
                "task_description": task.description,
                "task_due": task.due.isoformat() if task.due else None,
                "task_status": task.status.value if hasattr(task.status, 'value') else str(task.status),
                "reason": reason
            }
            
            deletion_log.append(deletion_entry)
            
            # Save updated deletion log
            with open(self.deletion_log_file, 'w') as f:
                json.dump(deletion_log, f, indent=2, default=str)
                
            logger.info(f"Logged deletion of task '{task.title}' (ID: {task.id}) - Reason: {reason}")
        except Exception as e:
            logger.error(f"Failed to log deletion: {e}")
    
    def _remove_duplicates_from_list(self, tasks: List[Task]) -> List[Task]:
        """
        Remove duplicate tasks from a list based on their signatures.
        
        Args:
            tasks: List of tasks to deduplicate
            
        Returns:
            List[Task]: Deduplicated list of tasks
        """
        unique_tasks = []
        seen_signatures = set()
        duplicates_removed = 0
        
        for task in tasks:
            # Combine description and notes since the signature function only takes description
            description = (task.description or "") + (task.notes or "")
            task_signature = create_task_signature(
                title=task.title or "",
                description=description,
                due_date=task.due,
                status=task.status
            )
            
            if task_signature not in seen_signatures:
                unique_tasks.append(task)
                seen_signatures.add(task_signature)
                logger.debug(f"Adding unique task: {task.title} (ID: {task.id}) with signature: {task_signature}")
            else:
                duplicates_removed += 1
                logger.info(f"Removing duplicate task: {task.title} (ID: {task.id}) with signature: {task_signature}")
        
        logger.info(f"Removed {duplicates_removed} duplicate tasks during deduplication")
        return unique_tasks
    
    def sync(self, push_only: bool = False, pull_only: bool = False) -> bool:
        """
        Perform simplified bidirectional synchronization with Google Tasks using the 4-step approach.
        
        Args:
            push_only: If True, only push local changes to Google Tasks
            pull_only: If True, only pull changes from Google Tasks
            
        Returns:
            bool: True if sync was successful, False otherwise
        """
        logger.info("Starting simplified bidirectional synchronization process")
        
        try:
            # Connect to Google Tasks
            if not self.google_client.connect():
                logger.error("Failed to connect to Google Tasks")
                return False
            
            # Check if local database is empty
            local_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
            is_db_empty = len(local_tasks) == 0
            
            if is_db_empty:
                logger.info("Local database is empty. Performing full sync.")
                # Step 1: Pull all remote records and save directly to main tables
                success = self._perform_full_sync()
            else:
                logger.info("Local database has data. Performing incremental sync.")
                # Step 2: Check default pull data range from config
                # Step 3: Pull only data in the specified time range
                # Step 4: Follow current process
                success = self._perform_incremental_sync(local_tasks, push_only, pull_only)
            
            if success:
                logger.info("Synchronization completed successfully")
                # Update sync metadata
                self.sync_metadata["last_sync"] = datetime.utcnow().isoformat()
                self._save_sync_metadata()
                return True
            else:
                logger.error("Synchronization failed")
                return False
                
        except Exception as e:
            logger.error(f"Error during synchronization: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def _perform_full_sync(self) -> bool:
        """
        Perform a full sync when local database is empty.
        
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            logger.info("Performing full sync - pulling all remote records")
            
            # Load all Google Tasks
            all_google_tasks = self._load_all_google_tasks_once()
            if all_google_tasks is None:
                logger.error("Failed to load Google Tasks")
                return False
            
            logger.info(f"Loaded {len(all_google_tasks)} Google Tasks")
            
            # Save all tasks directly to local storage
            task_dicts = [task.model_dump() for task in all_google_tasks]
            self.local_storage.save_tasks(task_dicts)
            
            logger.info("Full sync completed successfully")
            return True
            
        except Exception as e:
            logger.error(f"Error during full sync: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def _perform_incremental_sync(self, local_tasks: List[Task], push_only: bool, pull_only: bool) -> bool:
        """
        Perform an incremental sync when local database has data.
        
        Args:
            local_tasks: List of local tasks
            push_only: If True, only push local changes to Google Tasks
            pull_only: If True, only pull changes from Google Tasks
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            logger.info("Performing incremental sync")
            
            # Get default pull data range from config (default to 3 months)
            pull_range_days = self.config_manager.get('sync.pull_range_days', 90)  # Default 90 days = 3 months
            logger.info(f"Using pull range of {pull_range_days} days")
            
            # Calculate the minimum date for filtering
            min_date = datetime.utcnow() - timedelta(days=pull_range_days)
            min_date_iso = min_date.isoformat() + 'Z'  # RFC 3339 format
            
            logger.info(f"Loading Google Tasks from the last {pull_range_days} days (since {min_date_iso})")
            
            # Load Google Tasks filtered by date range
            filtered_google_tasks = self._load_filtered_google_tasks(min_date_iso)
            if filtered_google_tasks is None:
                logger.error("Failed to load filtered Google Tasks")
                return False
            
            logger.info(f"Loaded {len(filtered_google_tasks)} Google Tasks from the last {pull_range_days} days")
            
            # Create a set of existing signatures for duplicate checking (only Google Tasks)
            google_signatures = set()
            for task in filtered_google_tasks:
                # Combine description and notes since the signature function only takes description
                description = (task.description or "") + (task.notes or "")
                signature = create_task_signature(
                    title=task.title or "",
                    description=description,
                    due_date=task.due,
                    status=task.status
                )
                google_signatures.add(signature)
            
            logger.info(f"Retrieved {len(local_tasks)} local tasks")
            
            # Create a set of local task signatures for duplicate checking
            local_signatures = set()
            for task in local_tasks:
                # Combine description and notes since the signature function only takes description
                description = (task.description or "") + (task.notes or "")
                signature = create_task_signature(
                    title=task.title or "",
                    description=description,
                    due_date=task.due,
                    status=task.status
                )
                local_signatures.add(signature)
            
            # Store the Google signatures for use in push operations to prevent duplicates
            self._google_signatures = google_signatures
            
            # Step 2: Compare records based on latest changes
            logger.info("Step 2: Comparing records based on latest changes")
            sync_plan = self._compare_and_plan_changes(local_tasks, filtered_google_tasks)
            
            # Step 3: Check for duplicates and mark for removal
            logger.info("Step 3: Checking for duplicates")
            self._identify_and_mark_duplicates(sync_plan, local_tasks, filtered_google_tasks)
            
            # Step 4: Execute all changes
            logger.info("Step 4: Executing all changes")
            success = self._execute_sync_plan(sync_plan, push_only, pull_only)
            
            return success
            
        except Exception as e:
            logger.error(f"Error during incremental sync: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def _load_filtered_google_tasks(self, min_date_iso: str) -> List[Task]:
        """
        Load Google Tasks filtered by date range.
        
        Args:
            min_date_iso: Minimum date in ISO format to filter tasks
            
        Returns:
            List[Task]: List of filtered Google Tasks, or None if failed
        """
        try:
            logger.info(f"Loading Google Tasks with combined filters: min_date={min_date_iso}")
            
            # Get all tasklists
            tasklists = self.google_client.list_tasklists()
            if not tasklists:
                logger.error("Failed to retrieve tasklists from Google Tasks")
                return None
            
            # Collect all tasks from all tasklists with combined filters in a single call per tasklist
            all_tasks = []
            task_ids = set()  # To avoid duplicates
            
            for tasklist in tasklists:
                # Make a single call with combined filters to get maximum coverage
                # This will get tasks that match any of the criteria in one API call
                tasks = self.google_client.list_tasks_with_combined_filters(
                    tasklist_id=tasklist['id'],
                    min_date_iso=min_date_iso,
                    show_completed=True,
                    show_hidden=True,
                    show_deleted=False
                )
                
                # Add tasklist information and track unique tasks
                for task in tasks:
                    if task.id not in task_ids:
                        task.tasklist_id = tasklist['id']
                        all_tasks.append(task)
                        task_ids.add(task.id)
            
            logger.info(f"Successfully loaded {len(all_tasks)} unique filtered tasks from Google Tasks")
            return all_tasks
            
        except Exception as e:
            logger.error(f"Error loading filtered Google Tasks: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return None
    
    def _load_all_google_tasks_once(self) -> List[Task]:
        """
        Load all Google Tasks into memory once to avoid multiple API calls.
        
        Returns:
            List[Task]: List of all Google Tasks, or None if failed
        """
        try:
            logger.info("Loading all Google Tasks into memory")
            
            # Get all tasklists
            tasklists = self.google_client.list_tasklists()
            if not tasklists:
                logger.error("Failed to retrieve tasklists from Google Tasks")
                return None
            
            # Collect all tasks from all tasklists
            all_tasks = []
            for tasklist in tasklists:
                tasks = self.google_client.list_tasks(
                    tasklist_id=tasklist['id'],
                    show_completed=True,
                    show_hidden=True,
                    show_deleted=False
                )
                # Add tasklist information to each task
                for task in tasks:
                    task.tasklist_id = tasklist['id']
                all_tasks.extend(tasks)
            
            logger.info(f"Successfully loaded {len(all_tasks)} tasks from Google Tasks")
            return all_tasks
            
        except Exception as e:
            logger.error(f"Error loading Google Tasks: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return None
    
    def _compare_and_plan_changes(self, local_tasks: List[Task], google_tasks: List[Task]) -> Dict:
        """
        Compare local and remote tasks and create a sync plan.
        
        Args:
            local_tasks: List of local tasks
            google_tasks: List of Google tasks
            
        Returns:
            Dict: Sync plan with tasks to update/create/delete
        """
        # Create mappings for easier lookup
        local_task_dict = {task.id: task for task in local_tasks}
        google_task_dict = {task.id: task for task in google_tasks}
        
        # Create signature mappings for duplicate detection
        local_signature_map = self._create_signature_map(local_tasks)
        google_signature_map = self._create_signature_map(google_tasks)
        
        # Plan the changes
        sync_plan = {
            'update_remote': [],      # Local tasks that are newer than remote
            'create_remote': [],      # Local tasks that don't exist remotely
            'update_local': [],       # Remote tasks that are newer than local
            'create_local': [],       # Remote tasks that don't exist locally
            'remove_local_duplicates': [],
            'remove_remote_duplicates': [],
        }
        
        # Compare tasks by ID first
        all_task_ids = set(local_task_dict.keys()) | set(google_task_dict.keys())
        
        for task_id in all_task_ids:
            local_task = local_task_dict.get(task_id)
            google_task = google_task_dict.get(task_id)
            
            if local_task and google_task:
                # Task exists in both locations, compare modification times
                local_modified = local_task.modified_at or datetime.min
                google_modified = google_task.modified_at or datetime.min
                
                if local_modified > google_modified:
                    # Local is newer, update remote
                    sync_plan['update_remote'].append(local_task)
                    logger.debug(f"Task '{local_task.title}' (ID: {task_id}) - Local is newer")
                elif google_modified > local_modified:
                    # Remote is newer, update local
                    sync_plan['update_local'].append(google_task)
                    logger.debug(f"Task '{google_task.title}' (ID: {task_id}) - Remote is newer")
                else:
                    logger.debug(f"Task '{local_task.title}' (ID: {task_id}) - No changes")
            elif local_task:
                # Task only exists locally, check if it already exists remotely by signature
                # Combine description and notes since the signature function only takes description
                description = (local_task.description or "") + (local_task.notes or "")
                local_signature = create_task_signature(
                    title=local_task.title or "",
                    description=description,
                    due_date=local_task.due,
                    status=local_task.status
                )
                
                if local_signature in google_signature_map:
                    # Task already exists remotely, this is a duplicate
                    logger.debug(f"Task '{local_task.title}' (ID: {task_id}) - Already exists remotely, skipping creation")
                else:
                    # Task doesn't exist remotely
                    # Check if it was previously synced with Google Tasks (has a valid tasklist_id)
                    # Google Tasks tasklist IDs are long base64-like strings
                    if (hasattr(local_task, 'tasklist_id') and 
                        local_task.tasklist_id and 
                        len(local_task.tasklist_id) > 20):
                        # This task has a Google Tasks tasklist ID, which means it was previously synced
                        # Since it's no longer in Google Tasks, it was likely deleted
                        # Mark it as deleted locally
                        logger.debug(f"Task '{local_task.title}' (ID: {task_id}) - Previously synced with Google Tasks but no longer exists, marking as deleted locally")
                        local_task.status = TaskStatus.DELETED
                        sync_plan['remove_local_duplicates'].append(local_task)
                    else:
                        # Task doesn't exist remotely and wasn't previously synced, needs to be created
                        sync_plan['create_remote'].append(local_task)
                        logger.debug(f"Task '{local_task.title}' (ID: {task_id}) - New local task")
            elif google_task:
                # Task only exists remotely, check if it already exists locally by signature
                # Combine description and notes since the signature function only takes description
                description = (google_task.description or "") + (google_task.notes or "")
                google_signature = create_task_signature(
                    title=google_task.title or "",
                    description=description,
                    due_date=google_task.due,
                    status=google_task.status
                )
                
                if google_signature in local_signature_map:
                    # Task already exists locally, this is a duplicate
                    logger.debug(f"Task '{google_task.title}' (ID: {task_id}) - Already exists locally, skipping creation")
                else:
                    # Task doesn't exist locally, needs to be created
                    sync_plan['create_local'].append(google_task)
                    logger.debug(f"Task '{google_task.title}' (ID: {task_id}) - New remote task")
        
        return sync_plan
    
    def _create_signature_map(self, tasks: List[Task]) -> Dict[str, List[Task]]:
        """
        Create a mapping of task signatures to tasks for duplicate detection.
        
        Args:
            tasks: List of tasks
            
        Returns:
            Dict[str, List[Task]]: Mapping of signatures to tasks
        """
        signature_map = {}
        for task in tasks:
            # Combine description and notes since the signature function only takes description
            description = (task.description or "") + (task.notes or "")
            signature = create_task_signature(
                title=task.title or "",
                description=description,
                due_date=task.due,
                status=task.status
            )
            if signature not in signature_map:
                signature_map[signature] = []
            signature_map[signature].append(task)
        return signature_map
    
    def _identify_and_mark_duplicates(self, sync_plan: Dict, local_tasks: List[Task], google_tasks: List[Task]):
        """
        Identify duplicate tasks and mark them for removal.
        
        Args:
            sync_plan: The sync plan to update
            local_tasks: List of local tasks
            google_tasks: List of Google tasks
        """
        # Find duplicates in local tasks
        local_signature_map = self._create_signature_map(local_tasks)
        for signature, tasks in local_signature_map.items():
            if len(tasks) > 1:
                logger.debug(f"Found {len(tasks)} duplicate local tasks with signature {signature}")
                # Keep the first one, mark others for removal
                for task in tasks[1:]:
                    sync_plan['remove_local_duplicates'].append(task)
                    logger.debug(f"Marking local task '{task.title}' (ID: {task.id}) for removal")
        
        # Find duplicates in remote tasks
        google_signature_map = self._create_signature_map(google_tasks)
        for signature, tasks in google_signature_map.items():
            if len(tasks) > 1:
                logger.debug(f"Found {len(tasks)} duplicate remote tasks with signature {signature}")
                # Keep the first one, mark others for removal
                for task in tasks[1:]:
                    sync_plan['remove_remote_duplicates'].append(task)
                    logger.debug(f"Marking remote task '{task.title}' (ID: {task.id}) for removal")
    
    def _execute_sync_plan(self, sync_plan: Dict, push_only: bool, pull_only: bool) -> bool:
        """
        Execute the sync plan.
        
        Args:
            sync_plan: The sync plan to execute
            push_only: If True, only push changes
            pull_only: If True, only pull changes
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Handle push operations (if not pull_only)
            if not pull_only:
                logger.info("Executing push operations")
                push_success = self._execute_push_operations(sync_plan)
                if not push_success:
                    return False
            
            # Handle pull operations (if not push_only)
            if not push_only:
                logger.info("Executing pull operations")
                pull_success = self._execute_pull_operations(sync_plan)
                if not pull_success:
                    return False
            
            # Log summary
            logger.info("Sync execution summary:")
            logger.info(f"  Tasks to update in remote: {len(sync_plan['update_remote'])}")
            logger.info(f"  Tasks to create in remote: {len(sync_plan['create_remote'])}")
            logger.info(f"  Tasks to update in local: {len(sync_plan['update_local'])}")
            logger.info(f"  Tasks to create in local: {len(sync_plan['create_local'])}")
            logger.info(f"  Local duplicates removed: {len(sync_plan['remove_local_duplicates'])}")
            logger.info(f"  Remote duplicates removed: {len(sync_plan['remove_remote_duplicates'])}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error executing sync plan: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def _execute_push_operations(self, sync_plan: Dict) -> bool:
        """
        Execute push operations (local to remote).
        
        Args:
            sync_plan: The sync plan
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Check if there's anything to push
            tasks_to_push = (len(sync_plan['remove_local_duplicates']) + 
                           len(sync_plan['update_remote']) + 
                           len(sync_plan['create_remote']))
            
            if tasks_to_push == 0:
                logger.info("No tasks to push, skipping push operations")
                return True
            
            logger.info(f"Executing push operations for {tasks_to_push} tasks")
            
            # Remove local duplicates - we'll do this by marking them as deleted
            for task in sync_plan['remove_local_duplicates']:
                try:
                    # Use the storage's save_tasks method to update the task status
                    all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                    for t in all_tasks:
                        if t.id == task.id:
                            t.status = "deleted"
                            break
                    
                    # Save all tasks back
                    task_dicts = [t.model_dump() for t in all_tasks]
                    self.local_storage.save_tasks(task_dicts)
                    logger.debug(f"Marked duplicate local task as deleted: {task.title}")
                except Exception as e:
                    logger.warning(f"Failed to mark duplicate local task {task.title} as deleted: {e}")
            
            # Update remote tasks
            for task in sync_plan['update_remote']:
                try:
                    updated_task = self.google_client.update_task(task, task.tasklist_id)
                    if updated_task:
                        logger.debug(f"Updated task in Google: {task.title}")
                    else:
                        logger.warning(f"Failed to update task in Google: {task.title}")
                except Exception as e:
                    logger.error(f"Exception while updating task '{task.title}': {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            # Create remote tasks
            for task in sync_plan['create_remote']:
                try:
                    # Create task in Google Tasks, passing Google signatures to prevent additional API calls
                    new_task = self.google_client.create_task(task, self._google_signatures)
                    if new_task:
                        logger.debug(f"Created new task in Google: {task.title}")
                        # Update local task with new ID from Google
                        task.id = new_task.id
                        # Update tasklist_id if it doesn't exist
                        if not hasattr(task, 'tasklist_id') or not task.tasklist_id:
                            task.tasklist_id = new_task.tasklist_id
                            
                        # Update the task in local storage
                        all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                        # Find and replace the task with the updated one
                        for i, t in enumerate(all_tasks):
                            if t.id == task.id:
                                all_tasks[i] = task
                                break
                        else:
                            # If not found, add it
                            all_tasks.append(task)
                            
                        task_dicts = [t.model_dump() for t in all_tasks]
                        self.local_storage.save_tasks(task_dicts)
                        
                        # Add the new task's signature to our Google signatures set to prevent future duplicates
                        description = (task.description or "") + (task.notes or "")
                        signature = create_task_signature(
                            title=task.title or "",
                            description=description,
                            due_date=task.due,
                            status=task.status
                        )
                        self._google_signatures.add(signature)
                    else:
                        logger.warning(f"Failed to create task in Google: {task.title}")
                except Exception as e:
                    logger.error(f"Exception while creating task '{task.title}': {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error during push operations: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def _execute_pull_operations(self, sync_plan: Dict) -> bool:
        """
        Execute pull operations (remote to local).
        
        Args:
            sync_plan: The sync plan
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            # Remove remote duplicates - actually delete them from Google Tasks
            deleted_remote_count = 0
            for task in sync_plan['remove_remote_duplicates']:
                try:
                    # Delete the task from Google Tasks
                    if self.google_client.delete_task(task.id, task.tasklist_id):
                        logger.debug(f"Deleted duplicate remote task: {task.title} (ID: {task.id})")
                        deleted_remote_count += 1
                    else:
                        logger.warning(f"Failed to delete duplicate remote task: {task.title} (ID: {task.id})")
                except Exception as e:
                    logger.error(f"Exception while deleting remote task '{task.title}' (ID: {task.id}): {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            if deleted_remote_count > 0:
                logger.info(f"Deleted {deleted_remote_count} duplicate remote tasks from Google Tasks")
            
            # Remove local duplicates (including deleted tasks that no longer exist in Google Tasks)
            deleted_local_count = 0
            for task in sync_plan['remove_local_duplicates']:
                try:
                    if task.status == TaskStatus.DELETED:
                        # Actually delete the task from local storage
                        all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                        # Filter out the deleted task
                        remaining_tasks = [t for t in all_tasks if t.id != task.id]
                        # Save the remaining tasks
                        task_dicts = [t.model_dump() for t in remaining_tasks]
                        self.local_storage.save_tasks(task_dicts)
                        logger.debug(f"Deleted local task that no longer exists in Google Tasks: {task.title} (ID: {task.id})")
                        deleted_local_count += 1
                    else:
                        # Mark as deleted but keep in storage
                        all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                        # Find and update the specific task
                        for i, t in enumerate(all_tasks):
                            if t.id == task.id:
                                all_tasks[i].status = TaskStatus.DELETED
                                break
                        # Save all tasks
                        task_dicts = [t.model_dump() for t in all_tasks]
                        self.local_storage.save_tasks(task_dicts)
                        logger.debug(f"Marked local duplicate task as deleted: {task.title} (ID: {task.id})")
                        deleted_local_count += 1
                except Exception as e:
                    logger.error(f"Exception while handling local task '{task.title}' (ID: {task.id}): {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            if deleted_local_count > 0:
                logger.info(f"Handled {deleted_local_count} local tasks (deleted or marked as duplicates)")
            
            # Update local tasks
            updated_tasks = []
            for task in sync_plan['update_local']:
                try:
                    # Load all tasks
                    all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                    # Find and update the specific task
                    for i, t in enumerate(all_tasks):
                        if t.id == task.id:
                            all_tasks[i] = task
                            break
                    else:
                        # If not found, add it
                        all_tasks.append(task)
                    
                    # Save all tasks
                    task_dicts = [t.model_dump() for t in all_tasks]
                    self.local_storage.save_tasks(task_dicts)
                    updated_tasks.append(task)
                    logger.debug(f"Updated local task: {task.title}")
                except Exception as e:
                    logger.error(f"Exception while updating local task '{task.title}': {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            # Create local tasks
            created_tasks = []
            for task in sync_plan['create_local']:
                try:
                    # Load all tasks
                    all_tasks = [Task(**task_dict) for task_dict in self.local_storage.load_tasks()]
                    # Add the new task
                    all_tasks.append(task)
                    
                    # Save all tasks
                    task_dicts = [t.model_dump() for t in all_tasks]
                    self.local_storage.save_tasks(task_dicts)
                    created_tasks.append(task)
                    logger.debug(f"Created local task: {task.title}")
                except Exception as e:
                    logger.error(f"Exception while creating local task '{task.title}': {e}")
                    logger.error(f"Traceback: {traceback.format_exc()}")
            
            # Save synchronized tasks locally
            all_pulled_tasks = updated_tasks + created_tasks
            
            # Final deduplication pass to ensure no duplicates
            unique_tasks = self._remove_duplicates_from_list(all_pulled_tasks)
            
            # Create and save the list mapping
            list_mappings = self.local_storage.load_list_mapping()
            new_list_mapping = list_mappings.copy()  # Start with existing mappings
            
            # Update list mappings with any new tasklist IDs
            for task in unique_tasks:
                if hasattr(task, 'tasklist_id') and task.tasklist_id:
                    # Update mapping with tasklist ID if it's not already there
                    list_name = getattr(task, 'list_name', 'default')
                    if list_name not in new_list_mapping or not new_list_mapping[list_name]:
                        new_list_mapping[list_name] = task.tasklist_id
            
            # Save updated list mappings
            self.local_storage.save_list_mapping(new_list_mapping)
            
            logger.info(f"Pull operations completed: {len(updated_tasks)} updated, {len(created_tasks)} created, {deleted_local_count} local tasks handled, {deleted_remote_count} duplicates deleted")
            return True
            
        except Exception as e:
            logger.error(f"Error during pull operations: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return False
    
    def push_to_google(self) -> bool:
        """
        Push local changes to Google Tasks.
        Only uploads local tasks that don't exist in Google or are newer than Google versions.
        
        Returns:
            bool: True if push was successful, False otherwise
        """
        logger.info("Starting push to Google Tasks process")
        
        # Use the simplified sync approach with push_only flag
        return self.sync(push_only=True, pull_only=False)
    
    def pull_from_google(self) -> bool:
        """
        Pull changes from Google Tasks to local storage.
        Only downloads Google tasks that don't exist locally or are newer than local versions.
        
        Returns:
            bool: True if pull was successful, False otherwise
        """
        logger.info("Starting pull from Google Tasks process")
        
        # Use the simplified sync approach with pull_only flag
        return self.sync(push_only=False, pull_only=True)